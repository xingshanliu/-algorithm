方法1：BFS
步骤：
	1.计算所有结点的入度。
	2.从入度为0的结点开始广度搜索。
	3.当前驱结点被遍历到，后序结点的入度--，当结点的入度为0，才能继续遍历
	4.当队列为空，如果遍历过的结点等于所有结点。表示有拓扑序列
	
代码：
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        graph.assign(numCourses, {});
        into.assign(numCourses, 0);
        for (auto &edge : prerequisites) {
            int start = edge[1];
            int end = edge[0];
            graph[start].push_back(end);
            into[end]++;
        }

        vector<int> finish;
        for (int i = 0; i < numCourses; i++) {
            if (into[i] == 0) {
                q.push(i);
            }
        }

        while (!q.empty()) {
            int cur = q.front();
            finish.push_back(cur);
            q.pop();
            for (auto next : graph[cur]) {
                into[next]--;
                if (into[next] == 0) {
                    q.push(next);
                }
            }
        }

        if (finish.size() == numCourses) {
            return finish;
        }

        return {};
    }

    vector<vector<int>> graph;
    queue<int> q;
    vector<int> into;
};

方法1：DFS
步骤：
	1.DFS遍历所有没有访问的点
	2.结点有三种状态，0：没有被访问过 1：正在递归访问 3：已经访问完成回溯，可以记入拓扑序列
	3.遍历过程中如果遇到1的结点，说明有环，不呢形成拓扑排序
	4.记录的结果为倒序，需要处理
	
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        graph.assign(numCourses, {});
        into.assign(numCourses, 0);
        visted.assign(numCourses, 0);
        for (auto &edge : prerequisites) {
            int start = edge[1];
            int end = edge[0];
            graph[start].push_back(end);
        }
        valid = true;
        for (int i=0; i < numCourses; i++) {
            if (visted[i] == 0) {
                dfs(i); 
            }
        }
        if (valid) {
            reverse(ans.begin(), ans.end());        // 倒序处理
            return ans;
        }
        return {};
    }

    void dfs(int start) {
        visted[start] = 1;
        for (auto next : graph[start]) {
            if (visted[next] == 1) {               // 遇到环
                valid = false;
				return;
            }
             if (visted[next] == 0) {
                dfs(next);    
             }
        }
        visted[start] = 2;                       // 回溯结束，保存结果
        ans.push_back(start);
    }

    vector<vector<int>> graph;
    queue<int> q;
    vector<int> into;
    vector<int> visted;
    vector<int> ans;
    int valid;
};