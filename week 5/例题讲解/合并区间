题目:合并区间
	https://leetcode-cn.com/problems/merge-intervals/
思路1：
	1.将区间进行排序，规则：先按做左边界，再按右边界。
	2.初始化第一个区间为扩展区间，如果下一个区间的左边界小于等于当前区间的右边界，则合并这个区间。
	3.否则生成新的扩展区间，当前区间入答案队列。
代码2：
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end(), [](vector<int> &intervalA, 
            vector<int> &intervalB) {
            return (intervalA[0] < intervalB[0]) || 
                (intervalA[0] == intervalB[0] && intervalA[1] < intervalB[1]); 
        });

        vector<vector<int>> ans;
        int first = -1;
        int last = -1;
        for (auto interval : intervals) {
            int start = interval[0];
            int end = interval[1];
            if (start <= last) {
                last = max(last, end);     // 考虑包含场景，这里是取最大值
            } else {
                if (last != -1) {
                    ans.push_back({first, last});
                }
                first = start;
                last = end;
            }
        }
        ans.push_back({first, last});
        return ans;
    }
};

思路2：
	1.转换为差分事件，对事件进行排序。
	2.每一个事件给count赋值，赋值前count==0，新区间开始，赋值后count==0，区间结束
	
代码2：
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<pair<int, int>> event;
        for (auto &interval : intervals) {
            event.push_back({interval[0], 1});
            event.push_back({interval[1] + 1, -1});
        }
        
        sort(event.begin(), event.end());
        
        int count = 0;
        int start = 0;
        vector<vector<int>> ans;
        for (auto e : event) {
            if (count == 0) {
                start = e.first;
            }
            count += e.second;
            if (count == 0) {
                ans.push_back({start, e.first - 1});
            }
        } 

        return ans;
    }
};