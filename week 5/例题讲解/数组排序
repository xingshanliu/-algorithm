排序整体思想：
比较排序；
1.选择排序->堆排序
2.插入排序->希尔排序
3.冒泡排序（交换)->快速排序
4.归并排序

非比较排序：
1.计数排序
2.桶排序
3.基数排序(每一个位做计数排序)

稳定排序：归并排序、冒泡排序、计数排序、基数排序
不稳定排序：选择排序，堆排序，快速排序，希尔排序

1.排序数组
解法一：堆排序
代码：
class Solution {
public:    
	vector<int> sortArray(vector<int>& nums) 
	{    
        priority_queue<int> q;       
        for (auto num: nums) {
            q.push(-num);      // 大顶堆转换为小顶堆
        }

        for (int i = 0; i < nums.size(); i++) {
             nums[i] = -q.top();
             q.pop();
        }
		return nums;    
	}    
};

解法二：归并排序
class Solution {
public:    
	vector<int> sortArray(vector<int>& nums) 
	{    
        mergeSort(nums, 0, nums.size() - 1);
        return nums;      
	}
    
    void mergeArray(vector<int>& nums, int l, int mid, int r) {
        int totalLen = r - l + 1;
        int *tmpArray = new int[totalLen];

        int i = l;
        int j = mid + 1;
        for (int k = 0; k < totalLen; k++) {
            if (j > r || i <= mid && nums[i] <= nums[j]) {
                tmpArray[k] = nums[i++];
            } else {
                tmpArray[k] = nums[j++];
            }
        }

        for (int k = 0; k < totalLen; k++) {
            nums[l + k] = tmpArray[k];
        }
        delete[] tmpArray;
    }
    
    void mergeSort(vector<int>& nums, int l, int r) {
        if (l >= r) { 
            return;
        }

        int mid = (l + r) >> 1;
        mergeSort(nums, l, mid);
        mergeSort(nums, mid + 1, r);
        mergeArray(nums, l, mid, r);
    } 

};

解法三：快速排序
代码：
class Solution {
public:    
	vector<int> sortArray(vector<int>& nums) 
	{    
        quickSort(nums, 0, nums.size() - 1);
        return nums;      
	}

    int partition(vector<int>& nums, int l, int r) {
        int pivot = l + rand() % (r - l + 1);
        int pivotVal = nums[pivot];
        swap(nums[pivot], nums[r]);

        int i = l;
        for (int j = l; j < r; j++) {
            if (nums[j] < pivotVal) {
                swap(nums[i++], nums[j]);
            }
        }

        swap(nums[i], nums[r]);
        return i;
    }
    
    void quickSort(vector<int>& nums, int l, int r) {
        if (l >= r) { 
            return;
        }

        int pivot = partition(nums, l, r);
        quickSort(nums, l, pivot - 1);
        quickSort(nums, pivot + 1, r);
    } 

};