题目：数组的相对排序
	https://leetcode-cn.com/problems/relative-sort-array/
思路1：
	1.使用map记录array2中每个元素对应原数组的位置。
	2.采用sort进行排序，自定义比较函数。
	3.比较函数：首先比较map对应的顺序，如果不在map中，根据元素大小比较
代码1：
class Solution {
public:
    vector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2) {
        unordered_map<int, int> arr2Order;
        for (int i = 0; i < arr2.size(); i++) {
            arr2Order[arr2[i]] = i;
        }

        sort(arr1.begin(), arr1.end(), [&](int x, int y) {
            int posX = arr2Order.find(x) != arr2Order.end() ? 
                arr2Order[x] : arr2Order.size();

            int posY = arr2Order.find(y) != arr2Order.end() ? 
                arr2Order[y] : arr2Order.size();

            return (posX < posY) || (posX == posY && x < y);
        });

        return arr1;
    }
};

思路2：
	1.使用计数排序，使用count统计array1每个元素出现的个数
	2.优先查找array2在count中是否存在，记入答案。
	3.最后查找count中非0的元素，记入答案。
代码2：
class Solution {
public:
    vector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2) {
        vector<int> count(1001, 0);
        for (auto ele : arr1) {
            count[ele]++;
        }

        vector<int> ans;
        for (auto ele : arr2) {
            while (count[ele]) {
                ans.push_back(ele);
                count[ele]--;
            } 
        }

        for (int ele = 0; ele < count.size(); ele++) {
             while (count[ele]) {
                ans.push_back(ele);
                count[ele]--;
            } 
        }

        return ans;
    }
};

