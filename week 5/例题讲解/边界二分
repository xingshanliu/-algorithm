模板1：大于等于target中第一个
class Solution {
public:
    int findLeft(vector<int>& nums, int target) {
        int num = nums.size();
        int left = 0;
        int right = num;
        while (left < right) {              // 终止left == right，无解right == num
            int mid = (left + right) >> 1;
            if (nums[mid] >= target) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
		
        return right;
    }
};

题目1：寻找旋转排序数组中的最小值
	https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/

思路：
	1.题目转换为小于等于最后一个元素的数组。
	nums = [3,4,5,1,2]
           [0,0,0,1,1]
	2.寻找第一个1的位置
代码：
class Solution {
public:
    int findMin(vector<int>& nums) {
        int num = nums.size();
        int left = 0;
        int right = num;
        while (left < right) {
            int mid = (left + right) >> 1;
            if (nums[mid] <= nums[num - 1]) {           // 等于1
                right = mid;                            // 大于等于1中第一个，找小
            } else {
                left = mid + 1;
            }
        }

        return nums[right];
    }
};

模板2：小于等于target中最后一个
class Solution {
public:
    int findLeft(vector<int>& nums, int target) {
        int num = nums.size();
        int left = -1;
        int right = num - 1;
        while (left < right) {                 // 终止left == right，无解right == -1
            int mid = (left + right + 1) >> 1;
            if (nums[mid] <= target) {
                left = mid;
            } else {
                right = mid - 1;
            }
        }
		
        return right;
    }
};

题目2：在排序数组中查找元素的第一个和最后一个位置
	https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/
思路：	
	1.二分求左右边界。
	1.如果左边界 > 右边界无结果
代码：
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int num = nums.size();
        int left = 0;
        int right = num;
        while (left < right) {
            int mid = (left + right) >> 1;
            if (nums[mid] >= target) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }

        int start = right;
        left = -1;
        right = num - 1;
        while (left < right) {
            int mid = (left + right + 1) >> 1;
            if (nums[mid] <= target) {
                left = mid;
            } else {
                right = mid - 1;
            }
        }
        int end = right;
        if (start > end) {
            return {-1, -1};
        }
        return {start, end};
    }
};

题目3： Sqrt(x)
	https://leetcode-cn.com/problems/sqrtx/
思路：
	1.寻找一个数n*n <= x,即寻找小于等于x的最后一个n
代码：
class Solution {
public:
    int mySqrt(int x) {
        int left = 0;
        int right = x;
        while (left < right) {
            long long mid = (left + right + 1) >> 1;
            if (mid * mid <= x) {
                left = mid;
            } else {
                right = mid - 1;
            }
        }
        return right;
    }
};
