解题步骤:
1.人工模拟
	关注轮廓变化
2.定义状态
	关注代表以及它们之间的递推关系
3.确定最优子结构
	关注人工模拟时做出的决策。
4.写出状态转移方程
	边界：启动，不能访问的非法
5.确定边界、目标

题目1：零钱兑换
	https://leetcode-cn.com/problems/coin-change/
DP思路：
1.人工模拟:每次选择一种面值的硬币(指数型搜索)
2.定义状态：amount -> amount - coin。存在子问题。定义opt[i]为兑换1最少需要多少硬币。
3.确定最优子结构
4.写出状态转移方程:opt[i] = min(opt[i - coin] + 1);
5.确定边界、目标:边界opt[0] = 0，目标：opt[amount]
代码1(递推形式)：
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> amounts(amount + 1, 0);

        for (int i = 1; i <= amount; i++) {
            amounts[i] = 1e+5;
            for (auto coin : coins) {
                if (i - coin >= 0) {
                    amounts[i] = min(amounts[i], amounts[i - coin] + 1);
                }
            }
        }

        if (amounts[amount] >= 1e+5) {
            return -1;
        }

        return amounts[amount];
    }
};
代码2(记忆化搜索)：
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        amounts.assign(amount + 1, -1);
        int ans = dfs(coins, amount);
        if (ans >= 1e+5) {
            return -1;
        }
        return ans;
    }

    int dfs(vector<int>& coins, int amount) {
        if (amount == 0) {  // 边界:初值为0，或者已经兑换完
            return 0;
        }

        if (amount < 0) {   // 边界：无法兑换
            return 1e+5;
        }

        if (amounts[amount] != -1) {  // 重复子问题，计算过，直接返回
            return amounts[amount] ;
        }
        amounts[amount] = 1e+5;       // 赋初值
        for (auto coin : coins) {
            amounts[amount] = min(amounts[amount], dfs(coins, amount - coin) + 1);  // 递归
        }

        return amounts[amount];
    }
    vector<int> amounts;
};

题目2：不同路径 II
	https://leetcode-cn.com/problems/unique-paths-ii/
思路：
1.人工模拟：从左上结点，向右或者向下搜索。
2.定义状态
	a.自底向上：从(i,j)到end的路径数
	b.自顶向下：从start到(i,j)的路径数
3.确定最优子结构
4.写出状态转移方程：
	a.f(i, j) = f(i + 1, j) + f(i, j + 1);
	b.f(i, j) = f(i - 1, j) + f(i, j - i);
5.确定边界、目标
	a.边界：f(targetX, targetY) = 1; 障碍物为0；
	b.边界：f(0， 0) = 0，障碍物为0；目标：f(targetX， targetY); 
代码1（记忆化搜索）：
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
       m = obstacleGrid.size();
       n = obstacleGrid[0].size();
       paths.assign(m, vector<int>(n, -1));
       return dfs(obstacleGrid, 0, 0);
    }
    int m;
    int n;
    vector<vector<int>> paths;
    int dfs(vector<vector<int>>& obstacleGrid, int x, int y) {
        if (x < 0 || x >= m || y < 0 || y >= n || obstacleGrid[x][y] == 1) {
            return 0;
        }

        if (x == m - 1 && y == n - 1) {
            return 1;
        }

        if (paths[x][y] != -1) {
            return paths[x][y];
        }

        paths[x][y] = dfs(obstacleGrid, x + 1, y) + dfs(obstacleGrid, x, y + 1);
        return paths[x][y];
    }
};
代码2：
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
       int m = obstacleGrid.size();
       int n = obstacleGrid[0].size();
       vector<vector<int>> paths(m + 1, vector<int>(n + 1, 0));

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (obstacleGrid[i - 1][j - 1] == 1) {
                    paths[i][j] = 0;
                } else if (i == 1 && j == 1) {
                    paths[i][j] = 1;
                } else {
                    paths[i][j] = paths[i - 1][j] + paths[i][j - 1];       
                } 
            }
        }
       return paths[m][n];
    }
};
题目3：最长公共子序列
	https://leetcode-cn.com/problems/longest-common-subsequence/
代码：
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.size();
        int n = text2.size();
        vector<vector<int>> lcs(m + 1, vector<int>(n + 1, 0));
        text1 = " " + text1;
        text2 = " " + text2;
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (text1[i] == text2[j]) {
                    lcs[i][j] = lcs[i - 1][j - 1] + 1;
                } else {
                    lcs[i][j] = max(lcs[i][j - 1], lcs[i - 1][j]);
                }
            }
        }

        return lcs[m][n];
    }
};

题目4:最长递增子序列
思路：
1.人工模拟：如果aj > ai，j可能为lis
2.定义状态 f(j)：以j结尾的lis
3.确定最优子结构
4.写出状态转移方程：
	f(i) = max(f(j)) + 1  j < i
5.确定边界、目标
	边界：f(i) = 1; 目标：max(f(i))；
代码：
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int num = nums.size();
        vector<int> lis(num, 1);
        vector<int> pre(num, -1);

        for (int i = 1; i < num; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j] && lis[j] + 1 > lis[i]) {
                    lis[i] = lis[j] + 1;
                    pre[i] = j;
                }
            }
        }

        int ans = 0;
        int end = 0;
        for (int i = 0; i < num; i++) {
            if (lis[i] > ans) {
                ans = lis[i];
                end = i;
            }
        }
        printResult(end, nums, pre);
        return ans;
    }

    void printResult(int end, vector<int>& nums, vector<int> &pre) {
        if (end == -1) {
            return;
        }
        printResult(pre[end], nums, pre);
        cout<<nums[end]<<endl;
    }
};

题目5：最大子数组和
	https://leetcode-cn.com/problems/maximum-subarray/
1.人工模拟：以ai结尾的子序列，要么连接前面的序列，要么单独ai为序列
2.定义状态 f(i)以j结尾的最大子数组和
3.确定最优子结构
4.写出状态转移方程：
	f(i) = max(f(j) + nums[i], nums[i]);
5.确定边界、目标
	边界：f(i) = 0; 目标：max(f(i))；
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> maxSum(n + 1, 0);
        for (int i = 1; i <= n; i++) {
            maxSum[i] = max(maxSum[i - 1] + nums[i - 1], nums[i - 1]);
        }

        int ans = -1e+4;
        for (int i = 1; i <= n; i++) {
            ans = max(ans, maxSum[i]);
        }
        return ans;
    }
};

题目6：最大子数组和
https://leetcode-cn.com/problems/maximum-subarray/
代码：
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        vector <int> maxF(nums), minF(nums);
        for (int i = 1; i < nums.size(); ++i) {
            maxF[i] = max(maxF[i - 1] * nums[i], max(nums[i], minF[i - 1] * nums[i]));
            minF[i] = min(minF[i - 1] * nums[i], min(nums[i], maxF[i - 1] * nums[i]));
        }
        int ans = -1e+4;
        for (int i = 0; i < nums.size(); i++) {
            ans = max(ans, maxF[i]);
        }
        return ans;
    }
};