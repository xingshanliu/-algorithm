1.贪心属于奇技淫巧，一般思考问题，优先从搜索、动态规划出发，
2.贪心的证明方法：
a.决策包含性
题目1: 柠檬水找零
	https://leetcode-cn.com/problems/lemonade-change/
思路：
	1.由于面值成倍数关系，5,10,20，大面值能用小面值标识。
	2.优先选大面值，能包含小面值的决策
代码:
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        wallet[5] = 0;
        wallet[10] = 0;
        wallet[20] = 0;

        for (auto bill : bills) {
            wallet[bill]++;
            if (!exchang(bill - 5)) {
                return false;
            }
        }

        return true;
    }
    unordered_map<int, int> wallet;
    bool exchang(int memory) {
        if (memory == 0) {
            return true;
        }

        for (auto value : {10, 5}) {
            while (wallet[value] > 0 && memory >= value) {
                memory -= value;
                wallet[value]--;
            }
            if (memory == 0) {
                return true;
            }
        }

        return false;
    }
};

题目2: 分发饼干
	https://leetcode-cn.com/problems/assign-cookies/description
思路：
	1.大饼干给大孩子，小饼干给小孩
代码：
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        int j = g.size() - 1;
        int count = 0;
        for (int i = s.size() - 1; i >= 0; i--) {
            while (j >= 0 && s[i] < g[j]) {
                j--;                                 // 记录第一个满足的下标
            }

            if (j >= 0) {
                count++;
                j--;
            }
        }
        return count;
    }
};
b.决策范围扩展
题目3：买卖股票的最佳时机 II
	https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/
思路：
	1.向后多看一步，
	2.抓住每一段波段买入，如果明天比今天上涨，今天买入明天立马卖出。
代码:
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int profit = 0;
        for (int i = 1; i < prices.size(); i++) {
            profit += max(prices[i] - prices[i - 1], 0);
        }
        return profit;
    }
};

跳跃游戏 II
	https://leetcode-cn.com/problems/jump-game-ii/
思路：
	1.向后多看一步，
	2.在当前步移动范围内，寻找到跳到最远的位置。
	3.更远包含较近的决策，满足决策包含性。
代码：
class Solution {
public:
    int jump(vector<int>& nums) {
        int cur = 0;
        int end = nums.size() - 1;
        int count = 0;

        while (cur < end) {                   // 终止条件 cur == end
            int right = cur + nums[cur];
            if (right >= end) {
                return count + 1;
            }
            int next = cur;
            int distance = right;
            for (int i = cur; i <= right; i++) {
                if (i + nums[i] > distance) {
                    distance = i + nums[i];
                    next = i;
                }
            }

            count++;
            cur = next;
        }
        return count;
    }
};
c.邻项交换
题目：完成所有任务的最少初始能量
	https://leetcode-cn.com/problems/minimum-initial-energy-to-finish-tasks/
代码：
class Solution {
public:
    int minimumEffort(vector<vector<int>>& tasks) {
        sort(tasks.begin(), tasks.end(), [](const vector<int> &taskA, const vector<int> &taskB){
            return (taskA[0] - taskA[1]) < (taskB[0] - taskB[1]);
        });

        int ans = 0;
        for (int i = tasks.size() - 1; i >= 0; i--) {
            ans = max(tasks[i][1], ans + tasks[i][0]); 
        }

        return ans;
    }
};
