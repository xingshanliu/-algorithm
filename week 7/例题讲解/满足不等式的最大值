题目；满足不等式的最大值
https://leetcode-cn.com/problems/max-value-of-equation/
思路：
	1.问题简化：yi + yj + |xi - xj| 
	朴素做法：
	for (int i = 0; i < n; i++) {
		for (ini j = 0; j < n; j++) {
			if (i != j) {
				ans = max(min，yi + yj + |xi - xj|）； 
			}
		}
	}
	2.优化1，i和j相对顺序无关
	for (int i = 0; i < n; i++) {
		for (ini j = 0; j < i; j++) {
			ans = max(yi + yj + xi - xj); 
		}
	}
	
	2.优化2，可以分离出i
	for (int i = 0; i < n; i++) {
		for (ini j = 0; j < i; j++) {
			tmp = max(tmp, yj - xj); 
		}
		ans = tmp + xi + xj;
	}
	
	3.优化3，j随i变化，记录每一个i中j最大值，可以重复计算
	for (int i = 0; i < n; i++) {
		tmp = max(tmp, yi - xi); 
		ans = tmp + xi + xj;
	}
	
	4.增加条件|xi - xj| <= k,即xi >= xi + k,这是个下界。同时需要维护i前面中yj - xj最大，
	使用单调队列维护滑动窗口个。
	
代码：
class Solution {
public:
    int findMaxValueOfEquation(vector<vector<int>>& points, int k) {
        deque<int> q;
        int ans = -1e9;
        for (int i = 0; i < points.size(); i++) {
            // xj >= xi - k
            while (!q.empty() && points[q.front()][0] < points[i][0] - k) {
                q.pop_front();
            }

            if (!q.empty()) {
                ans = max(ans, points[i][0] + points[i][1] + points[q.front()][1] -  points[q.front()][0]);
            }

            // 单调队列维护最大值，单调递减
            while (!q.empty() && points[q.back()][1] -  points[q.back()][0] <= points[i][1] - points[i][0]) {
                q.pop_back();
            }
            q.push_back(i);
        }

        return ans;
    }
};